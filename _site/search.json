[
  {
    "objectID": "ojs.html",
    "href": "ojs.html",
    "title": "Observable Javascript",
    "section": "",
    "text": "Require p5\n\nP5 = require(\"p5\")\n\n\n\n\n\n\n\n\n\n```{ojs}\nlet cellSize = 20;\nlet columnCount;\nlet rowCount;\nlet currentCells = [];\nlet nextCells = [];\n\nfunction setup() {\n  // Set simulation framerate to 10 to avoid flickering\n  frameRate(10);\n  createCanvas(720, 400);\n\n  // Calculate columns and rows\n  columnCount = floor(width / cellSize);\n  rowCount = floor(height / cellSize);\n\n  // Set each column in current cells to an empty array\n  // This allows cells to be added to this array\n  // The index of the cell will be its row number\n  for (let column = 0; column &lt; columnCount; column++) {\n    currentCells[column] = [];\n  }\n\n  // Repeat the same process for the next cells\n  for (let column = 0; column &lt; columnCount; column++) {\n    nextCells[column] = [];\n  }\n\n  noLoop();\n  describe(\n    \"Grid of squares that switch between white and black, demonstrating a simulation of John Conway's Game of Life. When clicked, the simulation resets.\"\n  );\n}\n\nfunction draw() {\n  generate();\n  for (let column = 0; column &lt; columnCount; column++) {\n    for (let row = 0; row &lt; rowCount; row++) {\n      // Get cell value (0 or 1)\n      let cell = currentCells[column][row];\n\n      // Convert cell value to get black (0) for alive or white (255 (white) for dead\n      fill((1 - cell) * 255);\n      stroke(0);\n      rect(column * cellSize, row * cellSize, cellSize, cellSize);\n    }\n  }\n}\n\n// Reset board when mouse is pressed\nfunction mousePressed() {\n  randomizeBoard();\n  loop();\n}\n\n// Fill board randomly\nfunction randomizeBoard() {\n  for (let column = 0; column &lt; columnCount; column++) {\n    for (let row = 0; row &lt; rowCount; row++) {\n      // Randomly select value of either 0 (dead) or 1 (alive)\n      currentCells[column][row] = random([0, 1]);\n    }\n  }\n}\n\n// Create a new generation\nfunction generate() {\n  // Loop through every spot in our 2D array and count living neighbors\n  for (let column = 0; column &lt; columnCount; column++) {\n    for (let row = 0; row &lt; rowCount; row++) {\n      // Column left of current cell\n      // if column is at left edge, use modulus to wrap to right edge\n      let left = (column - 1 + columnCount) % columnCount;\n\n      // Column right of current cell\n      // if column is at right edge, use modulus to wrap to left edge\n      let right = (column + 1) % columnCount;\n\n      // Row above current cell\n      // if row is at top edge, use modulus to wrap to bottom edge\n      let above = (row - 1 + rowCount) % rowCount;\n\n      // Row below current cell\n      // if row is at bottom edge, use modulus to wrap to top edge\n      let below = (row + 1) % rowCount;\n\n      // Count living neighbors surrounding current cell\n      let neighbours =\n        currentCells[left][above] +\n        currentCells[column][above] +\n        currentCells[right][above] +\n        currentCells[left][row] +\n        currentCells[right][row] +\n        currentCells[left][below] +\n        currentCells[column][below] +\n        currentCells[right][below];\n\n      // Rules of Life\n      // 1. Any live cell with fewer than two live neighbours dies\n      // 2. Any live cell with more than three live neighbours dies\n      if (neighbours &lt; 2 || neighbours &gt; 3) {\n        nextCells[column][row] = 0;\n        // 4. Any dead cell with exactly three live neighbours will come to life.\n      } else if (neighbours === 3) {\n        nextCells[column][row] = 1;\n        // 3. Any live cell with two or three live neighbours lives, unchanged, to the next generation.\n      } else nextCells[column][row] = currentCells[column][row];\n    }\n  }\n\n  // Swap the current and next arrays for next generation\n  let temp = currentCells;\n  currentCells = nextCells;\n  nextCells = temp;\n}\n```\n\n\n\n\n\n\n\nOJS Syntax Error (line 18, column 1)The keyword ‘let’ is reserved\n\n\n\n\n\n\n\n\n\n\n\nExample from Danielle Navarro\nCreate function to draw donuts\n\n\nCode\nfunction* createSketch(sketch) {\n  const element = DOM.element('div');\n  yield element;\n  const instance = new P5(sketch, element, true);\n  try {\n    while (true) {\n      yield element;\n    }\n  } finally {\n    instance.remove();\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\nCode\ncreateSketch(s =&gt; {\n  \n    s.setup = function() {\n      s.createCanvas(500, 500);\n      s.background(0);\n      s.noStroke();\n    };\n    \n    s.draw = function() {\n      s.translate(\n        100 * s.cos(s.millis() * .001 * s.PI),\n        100 * s.sin(s.millis() * .001 * s.PI),\n      );\n      if (s.random(0, 1) &lt; .1) {\n        s.fill(s.random(0, 255));\n      }\n      s.circle(250, 250, 100);\n    };\n    \n  }\n)\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ncreateSketch(s =&gt; {\n\n  s.setup = function() {\n    s.createCanvas(746, 746, s.WEBGL);\n    s.noStroke();\n  }\n\n  s.draw = function() {\n\n    s.background(0);\n\n    let locX = s.mouseX - s.height / 2;\n    let locY = s.mouseY - s.width / 2;  \n    \n    s.ambientLight(60, 60, 60);\n    s.pointLight(190, 80, 190, locX, locY, 100);\n    s.pointLight(80, 80, 190, 0, 0, 100);\n  \n    s.specularMaterial(255);\n    s.rotateX(s.frameCount * 0.01);\n    s.rotateY(s.frameCount * 0.01);\n    s.torus(150, 80, 64, 64);\n  }\n\n})\n\n\n\n\n\n\n\n\n\n\n\nNotice if you move the mouse around, the light source changes"
  },
  {
    "objectID": "ojs.html#smoke-particle-example",
    "href": "ojs.html#smoke-particle-example",
    "title": "Observable Javascript",
    "section": "",
    "text": "```{ojs}\nlet cellSize = 20;\nlet columnCount;\nlet rowCount;\nlet currentCells = [];\nlet nextCells = [];\n\nfunction setup() {\n  // Set simulation framerate to 10 to avoid flickering\n  frameRate(10);\n  createCanvas(720, 400);\n\n  // Calculate columns and rows\n  columnCount = floor(width / cellSize);\n  rowCount = floor(height / cellSize);\n\n  // Set each column in current cells to an empty array\n  // This allows cells to be added to this array\n  // The index of the cell will be its row number\n  for (let column = 0; column &lt; columnCount; column++) {\n    currentCells[column] = [];\n  }\n\n  // Repeat the same process for the next cells\n  for (let column = 0; column &lt; columnCount; column++) {\n    nextCells[column] = [];\n  }\n\n  noLoop();\n  describe(\n    \"Grid of squares that switch between white and black, demonstrating a simulation of John Conway's Game of Life. When clicked, the simulation resets.\"\n  );\n}\n\nfunction draw() {\n  generate();\n  for (let column = 0; column &lt; columnCount; column++) {\n    for (let row = 0; row &lt; rowCount; row++) {\n      // Get cell value (0 or 1)\n      let cell = currentCells[column][row];\n\n      // Convert cell value to get black (0) for alive or white (255 (white) for dead\n      fill((1 - cell) * 255);\n      stroke(0);\n      rect(column * cellSize, row * cellSize, cellSize, cellSize);\n    }\n  }\n}\n\n// Reset board when mouse is pressed\nfunction mousePressed() {\n  randomizeBoard();\n  loop();\n}\n\n// Fill board randomly\nfunction randomizeBoard() {\n  for (let column = 0; column &lt; columnCount; column++) {\n    for (let row = 0; row &lt; rowCount; row++) {\n      // Randomly select value of either 0 (dead) or 1 (alive)\n      currentCells[column][row] = random([0, 1]);\n    }\n  }\n}\n\n// Create a new generation\nfunction generate() {\n  // Loop through every spot in our 2D array and count living neighbors\n  for (let column = 0; column &lt; columnCount; column++) {\n    for (let row = 0; row &lt; rowCount; row++) {\n      // Column left of current cell\n      // if column is at left edge, use modulus to wrap to right edge\n      let left = (column - 1 + columnCount) % columnCount;\n\n      // Column right of current cell\n      // if column is at right edge, use modulus to wrap to left edge\n      let right = (column + 1) % columnCount;\n\n      // Row above current cell\n      // if row is at top edge, use modulus to wrap to bottom edge\n      let above = (row - 1 + rowCount) % rowCount;\n\n      // Row below current cell\n      // if row is at bottom edge, use modulus to wrap to top edge\n      let below = (row + 1) % rowCount;\n\n      // Count living neighbors surrounding current cell\n      let neighbours =\n        currentCells[left][above] +\n        currentCells[column][above] +\n        currentCells[right][above] +\n        currentCells[left][row] +\n        currentCells[right][row] +\n        currentCells[left][below] +\n        currentCells[column][below] +\n        currentCells[right][below];\n\n      // Rules of Life\n      // 1. Any live cell with fewer than two live neighbours dies\n      // 2. Any live cell with more than three live neighbours dies\n      if (neighbours &lt; 2 || neighbours &gt; 3) {\n        nextCells[column][row] = 0;\n        // 4. Any dead cell with exactly three live neighbours will come to life.\n      } else if (neighbours === 3) {\n        nextCells[column][row] = 1;\n        // 3. Any live cell with two or three live neighbours lives, unchanged, to the next generation.\n      } else nextCells[column][row] = currentCells[column][row];\n    }\n  }\n\n  // Swap the current and next arrays for next generation\n  let temp = currentCells;\n  currentCells = nextCells;\n  nextCells = temp;\n}\n```\n\n\n\n\n\n\n\nOJS Syntax Error (line 18, column 1)The keyword ‘let’ is reserved"
  },
  {
    "objectID": "ojs.html#donut-example",
    "href": "ojs.html#donut-example",
    "title": "Observable Javascript",
    "section": "",
    "text": "Example from Danielle Navarro\nCreate function to draw donuts\n\n\nCode\nfunction* createSketch(sketch) {\n  const element = DOM.element('div');\n  yield element;\n  const instance = new P5(sketch, element, true);\n  try {\n    while (true) {\n      yield element;\n    }\n  } finally {\n    instance.remove();\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\nCode\ncreateSketch(s =&gt; {\n  \n    s.setup = function() {\n      s.createCanvas(500, 500);\n      s.background(0);\n      s.noStroke();\n    };\n    \n    s.draw = function() {\n      s.translate(\n        100 * s.cos(s.millis() * .001 * s.PI),\n        100 * s.sin(s.millis() * .001 * s.PI),\n      );\n      if (s.random(0, 1) &lt; .1) {\n        s.fill(s.random(0, 255));\n      }\n      s.circle(250, 250, 100);\n    };\n    \n  }\n)\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ncreateSketch(s =&gt; {\n\n  s.setup = function() {\n    s.createCanvas(746, 746, s.WEBGL);\n    s.noStroke();\n  }\n\n  s.draw = function() {\n\n    s.background(0);\n\n    let locX = s.mouseX - s.height / 2;\n    let locY = s.mouseY - s.width / 2;  \n    \n    s.ambientLight(60, 60, 60);\n    s.pointLight(190, 80, 190, locX, locY, 100);\n    s.pointLight(80, 80, 190, 0, 0, 100);\n  \n    s.specularMaterial(255);\n    s.rotateX(s.frameCount * 0.01);\n    s.rotateY(s.frameCount * 0.01);\n    s.torus(150, 80, 64, 64);\n  }\n\n})\n\n\n\n\n\n\n\n\n\n\n\nNotice if you move the mouse around, the light source changes"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Thomas Reinke",
    "section": "",
    "text": "Thomas Reinke is a PhD student studying statistics at Baylor University."
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Thomas Reinke",
    "section": "Education",
    "text": "Education\nSamford University | Birmingham, AL BS in Mathematics | Aug 2019 - May 2023"
  },
  {
    "objectID": "index.html#experience",
    "href": "index.html#experience",
    "title": "Thomas Reinke",
    "section": "Experience",
    "text": "Experience\nBlue Cross and Blue Shield of Alabama | Healthcare Analytics Intern | June 2022 - Aug 2022\nAutoTec | Data Analyst Intern | Feb 2022 - Apr 2022"
  },
  {
    "objectID": "index.html#languages-software",
    "href": "index.html#languages-software",
    "title": "Thomas Reinke",
    "section": "Languages & Software",
    "text": "Languages & Software\nR/Rstudio, Git/Github, Docker, SQL, Python, Java, AWS, Tableau, Toad"
  }
]